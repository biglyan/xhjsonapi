{"version":3,"sources":["xhjsonapi.min.js","/source/xhjsonapi.js","/source/src/xhjsonapi.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_get","_x","_x2","_x3","_again","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","getter","get","call","parent","getPrototypeOf","global","factory","exports","module","require","define","amd","XHJsonApi","Frisbee","this","_Frisbee","opts","_this","rpcPath","Error","methods","forEach","namespace","name","reduce","result","method","params","callback","payload","jsonrpc","id","post","credentials","body","JSON","stringify","then","response","_result","error","code","message"],"mappings":"AAEA,QAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,WAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIH,WAAU,iEAAoEG,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GAJje,GAAIW,MAAO,SAAaC,EAAIC,EAAKC,GAAqC,IAA9B,GAAIC,IAAS,EAAwBA,GAAQ,CAAE,GAAIC,GAASJ,EAAIK,EAAWJ,EAAKK,EAAWJ,CAAKC,IAAS,EAAsB,OAAXC,IAAiBA,EAASG,SAASlB,UAAW,IAAImB,GAAOlB,OAAOmB,yBAAyBL,EAAQC,EAAW,IAAaK,SAATF,EAAJ,CAA4O,GAAI,SAAWA,GAAQ,MAAOA,GAAKf,KAAgB,IAAIkB,GAASH,EAAKI,GAAK,IAAeF,SAAXC,EAAwB,MAAoB,OAAOA,GAAOE,KAAKP,GAA/V,GAAIQ,GAASxB,OAAOyB,eAAeX,EAAS,IAAe,OAAXU,EAAmB,MAA2Bd,GAAKc,EAAQb,EAAMI,EAAUH,EAAMI,EAAUH,GAAS,EAAMK,EAAOM,EAASJ,UCA5c,SAAWM,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,YAC9E,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,WAAYJ,GACjED,EAAOO,UAAYN,EAAQD,EAAOQ,UAClCC,KAAM,SAAUD,GAAW,YDY3B,IERmBD,GAAA,SAAAG,GAER,QAFQH,GAEPI,GFUR,GAAIC,GAAQH,IEPd,IFSE3C,gBAAgB2C,KEdDF,GAGjBxB,KAAAT,OAAAyB,eAHiBQ,EAAAlC,WAAA,cAAAoC,MAAAZ,KAAAY,KAGXE,IAEDF,KAAKE,KAAKE,QACb,KAAM,IAAIC,OAAM,uBAGlB,KAAKL,KAAKE,KAAKI,QACb,KAAM,IAAID,OAAM,sBAGlBL,MAAKE,KAAKI,QAAQC,QAAQ,SAACC,GACzBL,EAAKK,EAAUC,MAAQD,EAAUF,QAAQI,OAAO,SAACC,EAAQC,GAiCvD,MA/BAD,GAAOC,GAAU,SAACC,EAAQC,GACxB,GAAMC,IACJC,QAAS,MACTJ,OAAQJ,EAAUC,KAAO,IAAMG,EAC/BK,GAAI,EACJJ,OAAQA,EAGV,OAAOV,GAAKe,KAAKf,EAAKD,KAAKE,SAAUe,YAAa,UAAWC,KAAMC,KAAKC,UAAUP,IAAWD,GAC1FS,KAAK,SAACC,EAAUJ,GAEf,GAAoB,gBAATA,GAAmB,CAC5B,GAAMK,GAASL,EAAKT,OACde,EAAQN,EAAKM,KACnB,IAAKD,EAGE,KAAKC,GAOJ,GAAIrB,QAAOsB,KAAM,OAAQC,QAAS,WANnB,gBAAVF,IAAsBA,EAAMC,MAAQD,EAAME,QAC7C,GAAIvB,QAAOsB,KAAMD,EAAMC,KAAMC,QAASF,EAAME,UAE5C,GAAIvB,QAAOsB,KAAM,OAAQC,QAAS,eAL1C,QAAQjB,OAAAc,EAAQL,KAAAA,GAWlB,KAAM,IAAIf,QAAOsB,KAAM,OAAQC,QAAS,cAIzCjB,SFiBX,MAvDAlD,WETiBqC,EAAAG,GAAAH,GAAkBC,EDyDrC,OAAOD","file":"xhjsonapi.min.js","sourcesContent":["var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('frisbee')) : typeof define === 'function' && define.amd ? define(['frisbee'], factory) : global.XHJsonApi = factory(global.Frisbee);\n})(this, function (Frisbee) {\n  'use strict';\n\n  /**\n  生成符合 jsonrpc 2.0 规范的 api，基于 frisbee\n   @author zhangxhbeta\n  */\n\n  var XHJsonApi = (function (_Frisbee) {\n    _inherits(XHJsonApi, _Frisbee);\n\n    function XHJsonApi(opts) {\n      var _this = this;\n\n      _classCallCheck(this, XHJsonApi);\n\n      _get(Object.getPrototypeOf(XHJsonApi.prototype), 'constructor', this).call(this, opts);\n\n      if (!this.opts.rpcPath) {\n        throw new Error('需要提供rpc路径参数（rpcPath）');\n      }\n\n      if (!this.opts.methods) {\n        throw new Error('需要提供方法定义列表（methods）');\n      }\n\n      this.opts.methods.forEach(function (namespace) {\n        _this[namespace.name] = namespace.methods.reduce(function (result, method) {\n          // 依次设置方法函数\n          result[method] = function (params, callback) {\n            var payload = {\n              jsonrpc: '2.0',\n              method: namespace.name + '.' + method,\n              id: 1,\n              params: params\n            };\n\n            return _this.post(_this.opts.rpcPath, { credentials: 'include', body: JSON.stringify(payload) }, callback).then(function (response, body) {\n              // 这里接收到 body 和 原始的 response\n              if (typeof body === 'object') {\n                var _result = body.result;\n                var error = body.error;\n                if (!_result) {\n                  // 成功返回结果\n                  return { result: _result, body: body };\n                } else if (!error) {\n                  if (typeof error === 'object' && error.code && error.message) {\n                    throw new Error({ code: error.code, message: error.message });\n                  } else {\n                    throw new Error({ code: -32700, message: '无法解析响应的错误信息' });\n                  }\n                } else {\n                  throw new Error({ code: -32700, message: '无法解析响应' });\n                }\n              } else {\n                throw new Error({ code: -32700, message: '无法解析响应' });\n              }\n            });\n          };\n          return result;\n        }, {});\n      });\n    }\n\n    return XHJsonApi;\n  })(Frisbee);\n\n  return XHJsonApi;\n});\n//# sourceMappingURL=xhjsonapi.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('frisbee')) :\n  typeof define === 'function' && define.amd ? define(['frisbee'], factory) :\n  global.XHJsonApi = factory(global.Frisbee)\n}(this, function (Frisbee) { 'use strict';\n\n  /**\n  生成符合 jsonrpc 2.0 规范的 api，基于 frisbee\n\n  @author zhangxhbeta\n  */\n\n  class XHJsonApi extends Frisbee{\n\n    constructor(opts) {\n      super(opts);\n\n      if (!this.opts.rpcPath) {\n        throw new Error('需要提供rpc路径参数（rpcPath）');\n      }\n\n      if (!this.opts.methods) {\n        throw new Error('需要提供方法定义列表（methods）');\n      }\n\n      this.opts.methods.forEach((namespace) => {\n        this[namespace.name] = namespace.methods.reduce((result, method) => {\n          // 依次设置方法函数\n          result[method] = (params, callback) => {\n            const payload = {\n              jsonrpc: '2.0',\n              method: namespace.name + '.' + method,\n              id: 1,\n              params: params,\n            };\n\n            return this.post(this.opts.rpcPath, {credentials: 'include', body: JSON.stringify(payload)}, callback)\n              .then((response, body) => {\n                // 这里接收到 body 和 原始的 response\n                if (typeof body === 'object') {\n                  const result = body.result;\n                  const error = body.error;\n                  if (!result) {\n                    // 成功返回结果\n                    return {result, body};\n                  } else if (!error) {\n                    if (typeof error === 'object' && error.code && error.message) {\n                      throw new Error({code: error.code, message: error.message});\n                    } else {\n                      throw new Error({code: -32700, message: '无法解析响应的错误信息'});\n                    }\n                  } else {\n                    throw new Error({code: -32700, message: '无法解析响应'});\n                  }\n                } else {\n                  throw new Error({code: -32700, message: '无法解析响应'});\n                }\n              });\n          };\n          return result;\n        }, {});\n      });\n    }\n  }\n\n  return XHJsonApi;\n\n}));\n","/**\n生成符合 jsonrpc 2.0 规范的 api，基于 frisbee\n\n@author zhangxhbeta\n*/\n\nimport Frisbee from 'frisbee';\n\nexport default class XHJsonApi extends Frisbee{\n\n  constructor(opts) {\n    super(opts);\n\n    if (!this.opts.rpcPath) {\n      throw new Error('需要提供rpc路径参数（rpcPath）');\n    }\n\n    if (!this.opts.methods) {\n      throw new Error('需要提供方法定义列表（methods）');\n    }\n\n    this.opts.methods.forEach((namespace) => {\n      this[namespace.name] = namespace.methods.reduce((result, method) => {\n        // 依次设置方法函数\n        result[method] = (params, callback) => {\n          const payload = {\n            jsonrpc: '2.0',\n            method: namespace.name + '.' + method,\n            id: 1,\n            params: params,\n          };\n\n          return this.post(this.opts.rpcPath, {credentials: 'include', body: JSON.stringify(payload)}, callback)\n            .then((response, body) => {\n              // 这里接收到 body 和 原始的 response\n              if (typeof body === 'object') {\n                const result = body.result;\n                const error = body.error;\n                if (!result) {\n                  // 成功返回结果\n                  return {result, body};\n                } else if (!error) {\n                  if (typeof error === 'object' && error.code && error.message) {\n                    throw new Error({code: error.code, message: error.message});\n                  } else {\n                    throw new Error({code: -32700, message: '无法解析响应的错误信息'});\n                  }\n                } else {\n                  throw new Error({code: -32700, message: '无法解析响应'});\n                }\n              } else {\n                throw new Error({code: -32700, message: '无法解析响应'});\n              }\n            });\n        };\n        return result;\n      }, {});\n    });\n  }\n}\n"],"sourceRoot":"/source/"}